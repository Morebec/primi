<?php

namespace Smuuf\Primi;

use hafriedlander\Peg\Parser;

class CompiledParser extends Parser\Packrat {

	// Add these properties so PHPStan doesn't complain about undefined properties.

	/** @var int **/
	public $pos;

	/** @var string **/
	public $string;

/*!* Primi

# Previous StringLiteral regex causing PREG_JIT_STACKLIMIT_ERROR
# StringLiteral: /"(.|\n)*?"|'(.|\n)*?'/

# Carefully crafted (or stolen somewhere) string matching regex which supports
# both " and ' quotes, doesn't cause JIT stack overflow and supports escaped quotes.
StringLiteral: / (?:".*?(?<!\\)")|(?:'.*?(?<!\\)') /s
NumberLiteral: /-?\d+(\.\d+)?/
BoolLiteral: "true" | "false"
RegexLiteral: "/" /(\\\/|[^\/])+/ "/"

Literal: skip:NumberLiteral | skip:StringLiteral | skip:BoolLiteral | skip:RegexLiteral
VariableName: / ([a-zA-Z_][a-zA-Z0-9_]*) /
Variable: ( core:VariableName post:UnaryOperator? ) | ( pre:UnaryOperator? core:VariableName )
PropertyGetter: core:VariableName
AnonymousFunction: "function" __ "(" __ args:FunctionDefinitionArgumentList? __ ")" __ body:Block | "(" __ args:FunctionDefinitionArgumentList? __ ")" __ "=>" __ body:Block

ArrayItem: ( key:Expression __ ":" )? __ value:Expression )
ArrayDefinition: "[" __ ( items:ArrayItem ( __ "," __ items:ArrayItem )* )? __ ( "," __ )? "]"

Value: skip:Literal | skip:Variable | skip:ArrayDefinition
DereferencableValue: core:Value ( "[" __ dereference:Expression __ "]" )*
VariableVector: core:Variable ( "[" __ ( vector:Expression | vector:"" ) __ "]" )+
Mutable: skip:VariableVector | skip:VariableName

ObjectResolutionOperator: "."
AddOperator: "+" | "-"
MultiplyOperator: "*" | "/"
AssignmentOperator: "="
ComparisonOperator: "==" | "!=" | ">=" | "<=" | ">" | "<"
UnaryOperator: "++" | "--"

Expression: skip:AnonymousFunction | skip:Assignment | skip:Comparison | skip:Addition
Comparison: left:Addition __ op:ComparisonOperator __ right:Addition
Assignment: left:Mutable __ op:AssignmentOperator __ right:Expression
Addition: operands:Multiplication ( __ ops:AddOperator __ operands:Multiplication)*
Multiplication: operands:Operand ( __ ops:MultiplyOperator __ operands:Operand)*
Chain: ObjectResolutionOperator ( core:MethodCall | core:PropertyGetter ) ( chain:Chain )?
Operand: ( core:FunctionCall | "(" __ core:Expression __ ")" | core:DereferencableValue ) ( chain:Chain )?

MethodCall: method:VariableName "(" __ args:ArgumentList? __ ")"
FunctionCall: ( variable:VariableName | "(" __ value:Expression __ ")" ) "(" __ args:ArgumentList? __ ")"
ArgumentList: args:Expression ( __ "," __ args:Expression )*

FunctionDefinitionArgumentList: skip:VariableName ( __ "," __ skip:VariableName )*
FunctionDefinition: "function" [ function:VariableName __ "(" __ args:FunctionDefinitionArgumentList? __ ")" __ body:Block
IfStatement: "if" __ "(" __ left:Expression __ ")" __ ( right:Block )
WhileStatement: "while" __ "(" __ left:Expression __ ")" __ ( right:Block )
ForeachStatement: "foreach" __ "(" __ left:Expression __ "as" __ item:VariableName __ ")" __ ( right:Block )
CommandStatements: skip:EchoStatement | skip:ReturnStatement
EchoStatement: "echo" [ subject:Expression
ReturnStatement: "return" ( [ subject:Expression )?

# &/[A-Za-z]/ Ensures that no sub-rules will be even tried if the string does not start with a letter.
# And we know that our block statements always start with a letter.
BlockStatements: &/[A-Za-z]/ ( skip:IfStatement | skip:WhileStatement | skip:ForeachStatement | skip:FunctionDefinition )

# !/[\s\{\};]/ Ensures that we won't try to match further if any of those symbols are at the beginning of the substring we're matching.
Statement: !/[\s\{\};]/ ( skip:BlockStatements | skip:CommandStatements | skip:Expression )
Block: "{" __ ( skip:Program )? "}"

# Matches any optional whitespace or newline.
__: / [\s\n]* /

# Matches newline, takes care of optional // comments at EOL.
NL: / (?:\/\/[^\n]*)?\n /

# Statement separator: Newline or semicolon.
SEP: ";" | NL

# "!/$/" Ensures we won't try to find statements at EOF.
Program: ( !/$/ __ Statement? > SEP )+ __

*/

}
