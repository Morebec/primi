#!/usr/bin/env php
<?php

// Composer's autoload.
require __DIR__ . "/../vendor/autoload.php";

const SRC_DIR = __DIR__ . "/../src";

$coverage = false;
if ($argv[1] ?? null === '--coverage') {
	$coverage = true;
}

// Autoloader.
$loader = new \Smuuf\Koloader\Autoloader(__DIR__ . "/../temp/");
$loader->addDirectory(SRC_DIR)->register();

set_error_handler(function ($severity, $message, $file, $line) {
	throw new \ErrorException($message, 0, $severity, $file, $line);
});

function run_tests(): int {

	$success = true;
	foreach (glob(__DIR__ . "/../tests/*.primi") as $file) {
		$name = basename($file);
		info("Running test '$name' ... ", false);
		$success &= run_test($file);
	}

	return $success;

}

if ($coverage) {
	start_coverage();
}

$success = run_tests();

if ($coverage) {
	info(sprintf("Total coverage: %d %%", get_coverage()));
}

exit((int) !$success);

function run_test($file): bool {

	$context = new \Smuuf\Primi\Context;
	$interpreter = new \Smuuf\Primi\Interpreter($context);
	$outputFile = dirname($file) . "/" . basename($file, ".primi") . ".expect";

	ob_start();

		// Run interpreter
		$interpreter->run(file_get_contents($file));

		$vars = $context->getVariables();
		array_walk($vars, function($x, $k) {
			printf("%s:%s:%s\n", $k, get_class($x), return_string_value($x->getPhpValue()));
		});

	$output = ob_get_clean();

	$expected = @file_get_contents($outputFile);

	$expected = normalize($expected);
	$output = normalize($output);

	$lastExpectedFile = __DIR__ . '/../temp/last_expected.out';
	$lastActualFile = __DIR__ . '/../temp/last_actual.out';

	if ($expected !== $output) {
		info("FAIL", true, false);
		info("Diff:");
		info("", true, "░");
		file_put_contents($lastExpectedFile, $expected);
		file_put_contents($lastActualFile, $output);
		system("diff --unchanged-line-format='' --old-line-format='EXP(%dn) %L' --new-line-format='GOT(%dn) %L' $lastExpectedFile $lastActualFile");
		info("", true, "░");
		return false;
	} else {
		info("OK", true, false);
		return true;
	}

}

function info(string $string, $newline = true, $block = "█") {
	echo ($block ? "$block " : null) . $string . ($newline ? "\n" : null);
}

/**
 * Normalize WIN & LINUX new-lines to a single form - to reduce potential "false diffs".
 */
function normalize(string $string) {
	return preg_replace('~\r\n?~', "\n", $string);
}

/**
 * Serialize any supported value into a string form.
 */
function return_string_value($value) {
	if (is_array($value)) {
		$return = "[";
		foreach ($value as $key => $item) {
			$return .= sprintf("%s:%s,", $key, return_string_value($item->getPhpValue()));
		}
		$return = rtrim($return, ',') . "]";
	} elseif (is_bool($value)) {
		$return = $value ? 1 : 0;
	} else {
		$return = (string) $value;
	}
	return $return;
}

function start_coverage() {
	xdebug_start_code_coverage();
}

function get_coverage() {

	$total = 0;
	$ok = 0;

	// Get a list of all files inside source directory.
	$allFiles = find_all_files(SRC_DIR);

	foreach (xdebug_get_code_coverage() as $file => $lines) {

		// Skip files not in defined source directory.
		if (!in_array($file, $allFiles, true)) {
			continue;
		}

		// Gather total number of lines and number of lines marked as "ok" by xdebug coverage report.
		$total += count(file($file, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES));
		$ok += array_count_values($lines)[1] ?? 0;

	}

	// Return the total code coverage percentage.
	return $total ? round($ok / $total * 100, 2) : 0;

}

function find_all_files($dir): array {

	$result = [];
	$iterator = new RecursiveIteratorIterator(
		new RecursiveDirectoryIterator($dir, FilesystemIterator::SKIP_DOTS)
	);

	foreach ($iterator as $node) {

		$nodePath = $node->getRealPath();

		if (is_file($nodePath)) {
			$result[] = $nodePath;
		} elseif (is_dir($nodePath)) {
			foreach (find_all_files($nodePath) as $item) {
				$result[] = $item;
			}
		}

	}

	return $result;

}
