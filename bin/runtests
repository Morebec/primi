#!/usr/bin/env php
<?php

// Composer's autoload.
require __DIR__ . "/../vendor/autoload.php";

const SRC_DIR = __DIR__ . "/../src";

$coverage = false;
if ($argv[1] ?? null === '--coverage') {
	if (extension_loaded('xdebug')) {
		$coverage = true;
	} else {
		info("Xdebug not available: Won't measure code coverage.");
	}
}

// Autoloader.
$loader = new \Smuuf\Koloader\Autoloader(__DIR__ . "/../temp/");
$loader->addDirectory(SRC_DIR)->register();

set_error_handler(function ($severity, $message, $file, $line) {
	throw new \ErrorException($message, 0, $severity, $file, $line);
});

function run_tests(): int {

	$success = true;
	foreach (glob(__DIR__ . "/../tests/*.primi") as $file) {
		$name = basename($file);
		info("Running test '$name' ... ", false);
		$success &= run_test($file);
	}

	return $success;

}

if ($coverage) {
	start_coverage();
}

$success = run_tests();

if ($coverage) {
	info(sprintf("Total coverage: %d %%", get_coverage()));
}

exit((int) !$success);

function run_test($file): bool {

	$context = new \Smuuf\Primi\Context;
	$interpreter = new \Smuuf\Primi\Interpreter($context);
	$outputFile = dirname($file) . "/" . basename($file, ".primi") . ".expect";

	ob_start();

		try {

			// Run interpreter
			$interpreter->run(file_get_contents($file));

		} catch (\Smuuf\Primi\ErrorException $e) {

			printf("EX:%s\n", get_class($e));

		} finally {

			$vars = $context->getVariables();
			array_walk($vars, function($x, $k) {
				printf("%s:%s:%s\n", $k, get_class($x), return_string_value($x->getPhpValue()));
			});

		}

	$output = ob_get_clean();

	$expected = @file_get_contents($outputFile);

	$expected = normalize($expected);
	$output = normalize($output);

	$lastExpectedFile = __DIR__ . '/../temp/last_expected.out';
	$lastActualFile = __DIR__ . '/../temp/last_actual.out';

	if ($expected !== $output) {
		info("FAIL", true, false);
		info("Diff:");
		info("", true, "░");
		file_put_contents($lastExpectedFile, $expected);
		file_put_contents($lastActualFile, $output);
		system("diff --unchanged-line-format='' --old-line-format='EXP(%dn) %L' --new-line-format='GOT(%dn) %L' $lastExpectedFile $lastActualFile");
		info("", true, "░");
		return false;
	} else {
		info("OK", true, false);
		return true;
	}

}

function info(string $string, $newline = true, $block = "█") {
	echo ($block ? "$block " : null) . $string . ($newline ? "\n" : null);
}

/**
 * Normalize WIN & LINUX new-lines to a single form - to reduce potential "false diffs".
 */
function normalize(string $string) {
	return preg_replace('~\r\n?~', "\n", $string);
}

/**
 * Serialize any supported value into a string form.
 */
function return_string_value($value) {
	if (is_array($value)) {
		$return = "[";
		foreach ($value as $key => $item) {
			$return .= sprintf("%s:%s,", $key, return_string_value($item->getPhpValue()));
		}
		$return = rtrim($return, ',') . "]";
	} elseif (is_bool($value)) {
		$return = $value ? 1 : 0;
	} else {
		$return = (string) $value;
	}
	return $return;
}

function start_coverage() {
	xdebug_start_code_coverage(XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE);
}

function get_coverage() {

	$total = 0;
	$ok = 0;

	// Get a list of all files inside source directory.
	$allFiles = find_all_files(SRC_DIR);

	$coveredFiles = xdebug_get_code_coverage();

	foreach ($allFiles as $file) {

		if (!isset($coveredFiles[$file])) {
			$total += count(file($file, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES));
			continue;
		}

		$current = $coveredFiles[$file];
		$fileTotal = count($current);

		// Executed lines have index of 1, non-executable lines have -2.
		// These two sum up and are calculated against the number of lines considered by Xdebug as relevant.
		$fileOk = array_count_values($current)[1] ?? 0 + array_count_values($current)[-2];
		info(sprintf("File $file, Coverage: %d / %d", $fileOk, $fileTotal));
		file_put_contents(__DIR__ . '/../temp/cov_' . basename($file), print_r($current, true));
		$total += $fileTotal;
		$ok += $fileOk;

	}

	// Return the total code coverage percentage.
	return $total ? round($ok / $total * 100, 2) : 0;

}

function find_all_files($dir): array {

	$result = [];
	$iterator = new RecursiveIteratorIterator(
		new RecursiveDirectoryIterator($dir, FilesystemIterator::SKIP_DOTS)
	);

	foreach ($iterator as $node) {

		$nodePath = $node->getRealPath();

		if (is_file($nodePath)) {
			$result[] = $nodePath;
		} elseif (is_dir($nodePath)) {
			foreach (find_all_files($nodePath) as $item) {
				$result[] = $item;
			}
		}

	}

	return $result;

}
